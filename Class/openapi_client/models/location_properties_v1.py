# coding: utf-8

"""
    Digitraffic Road API

    [OpenAPI document](/swagger/openapi.json)   Digitraffic is a service operated by the [Fintraffic](https://www.fintraffic.fi) offering real time traffic information. Currently the service covers *road, marine and rail* traffic. More information can be found at the [Digitraffic website](https://www.digitraffic.fi/)   The service has a public Google-group [road.digitraffic.fi](https://groups.google.com/forum/#!forum/roaddigitrafficfi) for communication between developers, service administrators and Fintraffic. The discussion in the forum is mostly in Finnish, but you're welcome to communicate in English too.   ### General notes of the API * Many Digitraffic APIs use GeoJSON as data format. Definition of the GeoJSON format can be found at https://tools.ietf.org/html/rfc7946. * For dates and times [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format is used with \"Zulu\" zero offset from UTC unless otherwise specified (i.e., \"yyyy-mm-ddThh:mm:ss[.mmm]Z\"). E.g. 2019-11-01T06:30:00Z.

    The version of the OpenAPI document: Branch: master, tag: 2024.10.28-1 #ef5bdf3 @ 2024-10-29T08:05:03+0000
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class LocationPropertiesV1(BaseModel):
    """
    Location GeoJSON properties object
    """ # noqa: E501
    location_code: StrictInt = Field(description="Unique locationCode for this location", alias="locationCode")
    subtype_code: StrictStr = Field(description="Code of location subtype", alias="subtypeCode")
    road_junction: Optional[StrictStr] = Field(default=None, description="Roadnumber for roads. Junctionno: the numbering of exits has only just begun on the very limited Finnish motorway network. The exit numbers will be included. NOTE: the roads, segments and points are not sorted in ascending order", alias="roadJunction")
    road_name: Optional[StrictStr] = Field(default=None, description="Roadname if exists, L5.0 always have road name", alias="roadName")
    first_name: StrictStr = Field(description="For roads and segments this is the name of the starting point. For all other objects (linear (streets), area and point) this is the name of the object", alias="firstName")
    second_name: Optional[StrictStr] = Field(default=None, description="For roads and segments this is the name of the ending point. For point locations the number of the intersecting road", alias="secondName")
    area_ref: Optional[StrictInt] = Field(default=None, description="Code of the upper order administrative area", alias="areaRef")
    linear_ref: Optional[StrictInt] = Field(default=None, description="For segments and point locations. Describes the code of the segment which these objects belong to. If there are no segments on the road the location code of the road is given instead", alias="linearRef")
    neg_offset: Optional[StrictInt] = Field(default=None, description="For segments and point locations. Segments: describes the code of previous segment on that road. For the first segment on the road this code is 0. Points: describes the code of previous point on that road. For the starting point this code is 0", alias="negOffset")
    pos_offset: Optional[StrictInt] = Field(default=None, description="For segments and point locations. Segments: describes the code of next segment on that road. For the last segment on the road this code is 0. Points: describes the code of next point on that road. For the last point this code is 0", alias="posOffset")
    urban: Optional[StrictBool] = Field(default=None, description="Indicates whether a point is within the city limits (1) or not (0). NOTE: Not actively entered yet")
    coordinates_etrs89: Optional[List[Union[StrictFloat, StrictInt]]] = Field(default=None, description="Point coordinates (LONGITUDE, LATITUDE). Coordinates are in ETRS89 / ETRS-TM35FIN format.", alias="coordinatesETRS89")
    neg_direction: Optional[StrictStr] = Field(default=None, description="For all L5.0 and for some roads. Text to be used when the incident has an effect only on vehicles driving in the negative direction of the road. ( e.g. Ring 1 westbound)", alias="negDirection")
    pos_direction: Optional[StrictStr] = Field(default=None, description="For all L5.0 and for some roads. Text to be used when the incident has an effect only on vehicles driving in the positive direction of the road. ( e.g. Ring 1 eastbound)", alias="posDirection")
    geocode: Optional[StrictStr] = Field(default=None, description="Point location according to Finnish Transport Agencyâ€™s official addressing where Locations on road network are addressed as: Road number;Road part number;Carriageway; Distance from the beginning of the road part")
    order_of_point: Optional[StrictStr] = Field(default=None, description="The order of point within line or segment feature", alias="orderOfPoint")
    data_updated_time: datetime = Field(description="Data last updated time", alias="dataUpdatedTime")
    location_version: Optional[StrictStr] = Field(default=None, description="Location version", alias="locationVersion")
    __properties: ClassVar[List[str]] = ["locationCode", "subtypeCode", "roadJunction", "roadName", "firstName", "secondName", "areaRef", "linearRef", "negOffset", "posOffset", "urban", "coordinatesETRS89", "negDirection", "posDirection", "geocode", "orderOfPoint", "dataUpdatedTime", "locationVersion"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LocationPropertiesV1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LocationPropertiesV1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "locationCode": obj.get("locationCode"),
            "subtypeCode": obj.get("subtypeCode"),
            "roadJunction": obj.get("roadJunction"),
            "roadName": obj.get("roadName"),
            "firstName": obj.get("firstName"),
            "secondName": obj.get("secondName"),
            "areaRef": obj.get("areaRef"),
            "linearRef": obj.get("linearRef"),
            "negOffset": obj.get("negOffset"),
            "posOffset": obj.get("posOffset"),
            "urban": obj.get("urban"),
            "coordinatesETRS89": obj.get("coordinatesETRS89"),
            "negDirection": obj.get("negDirection"),
            "posDirection": obj.get("posDirection"),
            "geocode": obj.get("geocode"),
            "orderOfPoint": obj.get("orderOfPoint"),
            "dataUpdatedTime": obj.get("dataUpdatedTime"),
            "locationVersion": obj.get("locationVersion")
        })
        return _obj


